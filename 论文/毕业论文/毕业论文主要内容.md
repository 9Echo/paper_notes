## 毕业论文

[toc]

### 论文名称

基于钢铁物流的货物配载及**车辆调度/车货匹配/运力调度**相关研究

### 主要内容

1. 基于多目标优化的货物配载模型
2. 基于用户偏好的车货匹配推荐模型
3. 融合用户反馈信息的多级成对排序推荐模型

#### 排序学习相关工作

面向排序的推荐算法主要分为三类。

1. **点级（pointwise）**：输入包括用户、物品特征，根据排序的不同方式划分为回归和分类两种方法，本质上将排序问题退化为**回归与分类问题求解**。

   > - 常用的方法：
   >
   >   LR,GBDT,SVM等包括深度学习领域的排序模型。
   >
   > - 不足
   >   - 没有考虑物品间的关系，排序追求的是排序结果，并不要求精确打分，只需要相对打分即可。
   >   - 对于同一类别（标签）的物品没有做更细粒度的区分，预测概率也只是准确度概率，而不是真正排序靠前的预测概率。
   >   - 大多数排序情况中，排序结果的 top n 条的顺序重要性远比剩下全部顺序重要性高，所以排序靠前的物品和排序靠后的物品在用户偏好的表示程度上应该不一样，比如对于位置靠前但排序错误的物品应加大惩罚。

2. **对级（pairwise）**：考虑物品对之间的偏序关系，将问题转化为**有序分类**问题。对样本进行两两比较，构建偏序文档对，从比较中学习排序，因为对于一个查询关键字来说，最重要的其实不是针对某一个文档的相关性是否估计得准确，而是要能够正确估计一组物品之间的 “相对关系”。

   > - 常用的方法：
   >
   >   基于SVM的ranking svm，基于神经网络的ranknet，基于boosting的rankboost，贝叶斯个性化排序（BPR)
   >
   > - 不足：
   >
   >   - 训练样例是偏序物品对，它将对物品的排序转化为对不同物品与查询相关性大小关系的预测；因此，如果因某个物品相关性被预测错误，或物品对的两个物品相关性均被预测错误，则会影响与之关联的其它物品，进而引起连锁反应并影响最终排序结果。
   >   - 使用的是两物品之间相关度的损失函数，而它和真正衡量排序效果的指标之间存在很大不同，甚至可能是负相关的，如可能出现 Pairwise Loss 越来越低，但 NDCG 分数也越来越低的现象。
   >   - 如果相关物品量很大，转换为物品对之后，有的查询可能有几百对物品对，有的可能只有几十个，这样不加均一化地在一起学习，模型会优先考虑物品对数量多的查询，减少这些查询的 loss，最终对机器学习的效果评价造成困难。

3. **列表级（listwise）**：输入所有相关联的物品集合，更加全面地考虑物品的序列关系（近年热门），需要较大的样本量。目前大多数列表级排序法都是直接优化像NDCG这样的指标，从而能够学习到最佳排序结果（用什么衡量指标，就优化什么目标），这种方法叫基于 Measure-specific，还有一部分是根据一个已经知道的最优排序，尝试重建这个排序，然后来衡量这中间的差异，即基于Non-measure specific。

   > - 常用的算法：
   >
   >   - 基于 Measure-specific 的 SoftRank、SVM-MAP、SoftRank、LambdaRank、LambdaMART
   >
   >   - 基于 Non-measure specific 的 ListNet、ListMLE、BoltzRank。
   >
   > - 不足：
   >
   >   - 一些算法需要基于排列来计算 loss，从而使得训练复杂度较高。

#### 2.1 问题描述

获取当前可发库存，以及平台司机历史运输记录，根据历史发货记录，在符合业务规则的前提下，为当前报道司机推荐符合其偏好的货物。

#### 2.2 算法设计

> 排序学习结合推荐系统来预测某个特定司机对于待匹配货物的偏好，从而通过对货物的偏好分类来生成最终的推荐货物集合。
>
> 该算法根据司机的历史行为数据挖掘司机的偏好实现个性化车货匹配，共分为离线学习和在线推荐两个部分。
>
> - 离线学习：更新当前平台所有司机的个人信息、历史运载记录；根据历史运输记录挖掘司机偏好，学习司机特征向量、货物特征向量、司机货物交叉特征向量，作为在线推荐的输入；
> - 在线推荐：基于深度神经网络和逻辑回归模型为司机推荐符合其偏好的货物。

##### 排序学习框架

1. 获取/更新数据
   - 取最近十个月的历史摘单记录
2. 数据预处理
3. 特征工程

   - 特征提取

   - 人工标注标签
4. 模型训练
   - 基于Wide&Deep模型
5. 模型预测
6. 模型指标验证

##### 推荐模型设计

1. 新司机的冷启动问题

   > 缺陷：没有历史运输记录，导致司机和货物的关联矩阵稀疏。
   >
   > 常见方法：匹配物流信息平台热门货物榜单；基于最近邻推荐（基于最近邻用户列表推荐）；局部自动填充评分矩阵
   >
   > 根据司机属性与货物属性交叉组合，基于**随机游走PersonalRank算法**挖掘出相应交叉组合属性下司机喜好的货物，然后在喜好货物中提取交叉组合属性在整个物流信息平台中的热门运输货物组合推荐给司机。

2. 老司机的评分矩阵的稀疏问题

    > 由于平台的货物数量远远多过于司机数量，即便是老司机，也会存在对某些货物关联性不强，任意两个司机都有关联的货物交集也会更小，导致关联矩阵稀疏的情况。
    >
    > - 寻找司机与司机之间的特征
    >   - 根据司机特征生成**最近邻矩阵**，对邻近司机生成一个预测的评分来填补原始关联矩阵
    > - 寻找司机与货物之间的隐性特征
    >   - 在特征工程阶段引入**矩阵分解模型**生成老司机及货物的隐含向量，更加深入地刻画司机及货物在历史数据集上的表示，将司机和货物从单个维度映射到了几十、几百维的向量中，本质上是对司机和货物做了表示学习，最后将该隐含向量作为特征输入；
    >   - 根据司机的隐含向量，采用**K-means聚类**的方式将司机和货物聚成不同的类，这一类别表示基于历史行为数据的粗粒度的属性，该属性可以在相对较粗的粒度进行特征构造，提升模型的泛化能力。经过聚类后得特征向量作为wide模型的输入。


##### 评价指标

1. 准确率

2. 召回率

3. 平均准确率MAP

   > 考虑到物品之间的排序结果，与用户偏好越相关的物品排序越靠前越好，引入平均准确率。推荐列表中，某一位置k的准确率定义为物品在推荐列表和用户在测试集上实际喜欢的物品列表的交集中的位置，除以该物品在推荐列表中的位置
   > $$
   > P@k(u) = \frac{R(u) \cap T(u) @ k}{R(u) @ k} \cdot l_k
   > $$
   > 其中 $l_k$ 表示位置k处物品与用户的偏好是否相关：相关为1，不相关为0.
   >
   > 平均准确率及对用户u推荐列表中所有物品计算准确率
   > $$
   > AP(u) = \frac{\sum_{k=1}^{n_u}P@k(u)}{|R|}
   > $$
   > 其中， R 为用户 u 推荐列表长度， $n_u$ 表示用户 u 推荐列表中的所有物品
   >
   > 所有用户的平均准确率即MAP
   > $$
   > MAP = \frac{\sum_{u}AP(u)}{|U|}
   > $$
   > MAP 对排序位置敏感，值越大，说明与用户偏好相关的物品排序越靠前，排序性能也越好。

4. NDCG（normalized discounted cumulative gain）

#### 3 融合用户反馈信息的多级成对排序推荐模型

##### 存在的问题

1. 上一章的点级（Pointwise）方法本质上是在预测用户对一个物品的偏好程度，**但并没有考虑物品和物品之间的排序关系。**而列表级（Listwise）方法虽然优化了整个物品列表的排序，但在基于列表排序推荐模型中很难扩展融合物品有关的上下文信息，因此实际应用中效果并不理想。
2. 在车货匹配问题中，货物的数量远远多过于司机的数量，很多时候我们只能收集到少数正例样本，剩下的数据其实是真实负例和缺失值的混合构成（这里的缺失值是指训练数据中除正例和负例外的未知数据，缺失值中的样本即有可能是正例，也有可能是负例）。这样的模型**仅能预测正例或负例，对于类别内的样本无法深入区别其重要性**，不利于排序。

##### 模型优化

1. 加入用户反馈数据。

   > 实际上线开单过程中，将人工修改的开单结果作为反馈数据，通过对比原开单结果和实际开单结果，为训练数据生成配对样本。

2. 使用配对法构建排序学习模型。

   > 相比于单点法的矩阵分解，基于配对法的 BPR（贝叶斯个性化排序） 有两大**优势**：
   >
   > 1. 训练数据由正样本，负样本和缺失值构成。两个未观测到的物品的缺失值正好就是以后需要进行排序的物品对。这意味着从成对训练的角度，训练数据 DS 和测试数据是不相交的。
   > 2. 训练数据是为后面的排序目标函数生成的，也就是观测值 >u 的子集 DS 被用作训练数据

##### 基于BRP模型的推荐算法设计

BRP：贝叶斯个性化排序基于贝叶斯理论的后验估计最大化模型。

输入：训练集 D 三元组，梯度步长 $\alpha$ ，正则化参数 $\lambda$，分解矩阵维度 k

输出： 模型参数，矩阵 W, H

1. 随机初始化矩阵 W, H
2. 迭代更新模型参数
3. 如果 W, H收敛，则结束，否则回到步骤2

得到 W, H后，计算每一个用户 u 对应的任意一个商品的排序分：$x_{ui} = w_u \cdot h_i$，最终选择排序分数最高的若干商品输出。

##### 实验分析

1. 算法性能

   > 本文所提算法和其他经典排序算法针对四个评价指标的对比

2. 矩阵分解维度对比

   > 对比不同矩阵分解的维度对不同排序算法的性能影响
