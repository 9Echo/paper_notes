<<<<<<< Updated upstream
## 小论文

### 没有解决的问题

- 目标设定：车次数最少等价于单辆车的货物总重量最大                                                                                                                       

- 画图（几张图？）

- 转换为word格式（数学公式）



1. 在遗传算法的基础上，设计一个全新的算法，相关工作都列出来算法，及思路，遗传算法和帕累托算法结合设计的新的算法

2. 相关工作写到问题定义后面，没有可以完全应用的场景的代表性算法，不同方向的算法挑一个代表性算法（不止是遗传算法）为什么从遗传算法的角度来写。一定要写明为什么遗传算法，这是主要的方法。问题是np的，（参考文献证明），近似算法为什么用遗传算法，

   > 启发式算法是多目标优化问题现有研究中最常见的解决方案。由于NP问题一般的数学方法无法在有限时间内求解，因此采用启发式算法在可接受时间范围内得到待解决离散最优化问题的可行近似最优解，常用的算法主要有遗传算法、蚁群算法、模拟退火算法等。而遗传算法是模仿生物群落演化的过程，实现随着时间群组不断演化最后收敛的算法，其主要模仿的是自然中个体和基因繁殖、杂交和变异的现象，因此遗传算法的过程主要包括四个组成部分：初始种群的表示方式、优秀个体的选择、基因之间的交叉、基因自身的变异。
   >
   > 
   >
   > 遗传算法：处理离散问题，很好的处理约束问题，跳出局部最优得到全局最优解，全局搜索能力强；
   >
   > 模拟退火：局部搜索能力强，全局搜索能力差，容易受到参数的影响
   >
   > 爬山算法：简单、效率高，不适合处理大规模多约束问题
   >
   > 粒子群算法：容易陷入局部最优，不是全局收敛，适合求解实数问题
   >
   > 蚁群算法：参数设置复杂，参数设置不当，容易偏离优质解

3. 场景文字描述，分货过程有多个目标，再用数学语言写出来，

多目标在这个场景下没有工作，其他场景有类似的，已经证明是np问题，参考文献，第一类方法如何解决（思路）代表性的论文，什么场景用了这个方法，第二类、第三类。。

我选择遗传算法的原因，

- 算法框架：货物预处理，候选集，得到结果（遗传算法的框架）
- 求近似解的思路，
- 为什么这么设计？两大段文字？（700字design思路）





1. 模型
2. 算法框架+可以求出这个解（和其他算法比较，为什么要这么设计这个算法，结合相关工作和场景）
   - 能不能求准确解（用近似算法）
   - 为什么要选帕累托概念（别人的算法证明效果要好，可以体现目标之间的冲突，当前的场景适用这种方法，所以适用）
3. 收敛的速度很慢，对算法做优化（性能）
4. 或者结合2和3点，快速收敛（帕累托+遗传算法）的算法，将算法特点，np的，帕累托方法，做出决策的原因，存在收敛的问题，为了应对这些挑战，做的设计。
5. 遗传算法，权重的速度快，解的质量不高，帕累托的解质量高，速度慢，如何在保证解的质量的情况下加快迭代的速度。

### 摘要

> 200-400字
>
> 摘要应简明扼要，避免一般背景介绍，应包括研究目的，方法及过程，结果和结论这些要素，不要出现“本文”、“我们”之类词



### 0 引言

> - 背景说明
> - 相关工作
> - 本文贡献

#### 相关工作

- [ ] 补其他智能算法

#### 本文贡献

1. 设计了一套货物配载多目标优化模型

### 1 多目标货物配载模型

#### 1.1 问题描述（研究动机）

物流平台每天在零点获取仓库的库存数据，结合货物的品种、仓库、规格等特征以及不同品种的货物之间拼货时需满足的限制条件，对客户订单进行拆分、组合，生成一批装车清单，并上传至平台供司机选择。当前平台使用的配载方法是通过顺序遍历货物列表，在符合业务规则的条件下，以最大化单辆车的货物重量为目标为车次分配货物。该方法没有考虑到后续的货物信息和剩余空车次数量，无法实现全局最优的货物分配，导致大量货物积压，部分单车货物重量远低于车辆载重上限。

针对上述货物配载效率太低及货车利用率不高等问题，本文提出了多目标优化货物配载模型，根据实际的业务调研结果，从物流平台和货车司机双方的角度考虑，设计以下3个具有实际应用价值的目标。从物流平台的角度考虑，通过增加单批次所有订单的货物总重量，减少单批次订单数即减少车次数来降低平台成本，与此同时在货车不超载的情况下尽可能增大单辆车的装载重量，从而在提高配载效率的同时可以提升平台经济收益；从货车司机的角度考虑，尽可能降低货车中货物的装卸地数量，可减少司机的时间成本，给司机带来最大的便利。同时这三个目标具有优先级，优先最大化所有订单的货物总重量，其次减少总订单数，减少总订单的货物装卸地优先级最低。

#### 1.2 数学模型

> - 三个目标方程及对应的解释说明
> - 约束条件及解释说明

根据对货物配载问题的分析，货物配载模型主要参数如下：

本文使用 $T_i(1\le i \le m)$ 表示可供使用的车次中第 $i$ 辆车；$C_j(1 \le j \le n)$表示当前库存可发运货物中第 $j$ 件货物；使用装车清单描述车辆依次运输任务需要装载的货物情况；$w_j$ 表示货物 $C_j$ 的重量，单位为吨；$l_i$ 表示车辆 T_i 的载重上限，单位为吨，并根据货物卸货地进行区分；$q_i$ 表示车辆 T_i 上的货物装卸地数总和，可能的取值为2，3，4，每辆货车的装卸情况至少是一装一卸，最多两装两卸。

模型的目标方程如下所示：
$$
\begin{cases}
\begin{align}
& maximize \ \ \ \ \ \ \  f_1 = \sum_{i=1}^m\sum_{j=1}^n w_jx_{ij} \\
& maximize \ \ \ \ \ \ \  f_2 = \sum_{j=1}^nw_jx_{ij} \\
& minimize \ \ \ \ \ \ \  f_3 =  \sum_{i=1}^mq_i
             \\
& subject \ \ to.\quad \ \sum_{j=1}^nw_jx_{ij} \leq l_i ,\quad i \in M = \left \{ 1, \cdots, m \right \} .\\
& \ \quad \quad \quad \quad \quad \quad \sum_{i=1}^nx_{ij} \leq 1 , \quad j \in N = \left \{ 1, \cdots, n \right \} .\\
& 其中 \ \quad\quad \quad\quad \ 
x_{ij}=
\begin{cases} 
0,\quad 如果货物 j 没有被分配至货车 i \\
1,\quad 如果货物 j 被分配至货车 i 
\end{cases}
\end{align}
\end{cases}
$$

（1）最大化总订单货物重量

（2）最大化单辆车货物总重量

（3）最小化货车货物装卸地数量

式中的 $x_{ij}$ 为0或者1，表示货物 Cj 是否被分配至车辆 Ti 中。

约束条件：

1. 每件货只能被放置一次，不可同时被放置在不同的车辆中
2. 每辆车中装载的货物总重量不得超过货车的载重上限

### 2 Pareto dominated genetic algorithm（PDGA）算法求解多目标货物配载模型

> 1. 传统的遗传算法的缺点
>    - 实际问题中目标互相冲突，传统的遗传算法（适应度函数：单目标优化）没有体现多目标的竞争性
>      - 提出帕累托支配概念
>    - 约束条件过于复杂，无法找到可行解
>      - 提出精英保留策略
> 2. 每个修改的过程具体描述
>    - - [ ] Pareto结构
>      - [ ] 精英策略
>      - [ ] 步骤流程
> 3. xx算法的流程说明
> 4. 附上流程图（伪代码）

遗传算法是模仿生物群落演化的过程，实现随着时间群组不断演化最后收敛的算法，其主要模仿的是自然中个体和基因繁殖、杂交和变异的现象，因此遗传算法的过程主要包括四个组成部分：初始种群的表示方式、优秀个体的选择、基因之间的交叉、基因自身的变异。

本文在对历史数据的统计与分析过程中发现，在实际的货物配载过程中，最大化总订单货物重量往往需要对多份货物进行拆分重新组合，与此同时，单份订单中的货物装卸地数量也随之增加，这表明配载过程中多个目标之间互相冲突，而传统的遗传算法并不能体现多个目标之间的冲突与竞争关系。

遗传算法在进化过程选择个体时，普遍采用随机结构，但受制于配载过程中严格的约束条件，随机挑选的个体极有可能都不符合配载规则，导致种群进化过程中需要耗费大量的时间寻找第一代可行解，严重影响计算效率，而一旦种群在进化过程中产生了符合约束的个体，种群会提前进入收敛状态，导致最终得到的最优解质量较差。

遗传算法本身依靠基因之间的交叉与变异这对相互配合又相互竞争的操作而使其具备兼顾全局和局部的均衡搜索能力，在复杂约束条件下，传统的交叉、变异方法可能会失去作用，交叉或变异操作都可能会破坏掉原本已有的优秀个体的基因结构，导致解的多样性不足，即便进入种群进化的中后期，最终解仍然有可能停留在找到第一代可行解的阶段。

针对以上问题，本文提出xx算法，主要在遗传算法（GA）的基础上进行了以下三个部分的优化：

1. 引入基于Pareto支配关系的分层结构。[参考文献]提出帕累托最优，[参考文献]提出帕累托支配关系，利用Pareto支配关系对个体进行分层，使得更优秀的个体基因以更大的概率被保留到下一代种群中。
2. 采用改进的精英保留策略。通过Pareto支配关系对个体进行分层后，保留父代种群中的非支配解，使其直接进入子代种群，避免父代中优秀个体的丢失。
3. 设计独立的交叉、变异算子。根据约束条件设计特殊的交叉、变异操作，提高算法局部搜索能力的同时加快种群收敛的速度。

#### 2.1 基于Pareto支配关系的分层结构

[帕累托]在1986年提出多目标优化问题中Pareto支配关系的概念，其定义为：假设任何二解S1及S2对所有目标而言，S1均优于S2，则称S1支配S2，若S1没有被其他解所支配，则S1称为非支配解（不受支配的解），也称为Pareto解，S2称为受支配解。在多目标优化问题中，如果目标之间存在冲突与竞争关系，会存在多个非支配解，此时一组目标函数最优解的表示形式为Pareto最优解集。

相关数学定义如下所示。

**定义1** （Pareto支配）设 x 和 y 是种群中任意两个个体，需满足如下约束条件，则称 x 支配 y，记作 $x \succ y$
$$
\begin{cases}
\begin{aligned}
f_i(x) \le f_i(y), \quad {\forall}i=1, 2, \dots, m \\
f_j(x) < f_j(y), \quad {\exists}j = 1, 2, \dots, m
\end{aligned}
\end{cases}
$$
**定义2**（非支配解） 设 x 是集合 Q 中的任意解，需满足式xx（下式用数字表示），则称x为集合Q中的非支配解
$$
{\nexists}y \in Q: y\succ x
$$
**定义3**（Pareto最优解）设可行域 R 中任意两个个体 x 与 y，需满足式xx，则称个体 x 为Pareto最优解
$$
{\nexists}y\in R: y\succ x
$$
**定义4**（Pareto最优解集）可行域R中所有的Pareto最优解组成Pareto最优解集（Pareto Set，PS）
$$
S = \lbrace x \mid x\in R \ \ \text{且} x \text{是} Pareto\text{最优解}\rbrace
$$
**定义5**（Pareto前沿）Pareto最优解集中所有Pareto最优解在目标空间上的映射，称为：Pareto前沿（Pareto Front，PF）
$$
PF = \lbrace f(x) \in R \mid x \in PS\rbrace
$$


将种群中的个体根据支配关系进行分层。

> step (1) 设 $j=1$;
>
> step (2) 对于所有的 $g=1,2,...,N$ 且 $g \neq j$ ，基于适应度函数比较个体 $x^j$ 和个体 $x^g$ 之间的支配与非支配关系；
>
> step (3) 如果不存在任何一个个体 $x^g$  优于 $x^j$ ，那么 $x^j$ 被标记为非支配个体；
>
> step (4) 令 $j = j+1$，重复步骤 (1)，直到找到所有的非支配个体

步骤(1) - 步骤(4) 可得到**第一级非支配层**；忽略这些非支配个体，重复步骤(1)-步骤(4) ，得到**第二级非支配层**，以此类推，直到所有种群中的个体被分类。

#### 2.2 精英保留策略

[De Jong KA. Analysis of the behavior of a class of genetic adaptive systems. 1975.]提出精英保留策略，其核心思想是把种群进化过程中出现的精英个体复制到下一代中。但是传统精英策略存在保持种群多样性能力差、易于收敛于局部最优等问题，本文对其进行了改进：

1. 对各等级非支配层上的个体进行拥挤度排序；

2. 为了保留尽可能多的精英解，将位于1级非支配层上的所有个体直接选入子代，若其数量超过子代种群数量N的0.15倍，则按照拥挤度排序选择前0.15N个个体进入子代；

3. 对其他等级非支配层上的个体，由于选取的精英个体数量不超过种群总个体数量的30%，除第一层外个体数，剩余的名额平均分配给每一层非支配层。

4. 分别按在种群大小为 N_p 的合并种群中所占的比例，选取 N_i 个个体进入子代。

   其中，，每级非支配层个体数量选择函数如下：
   $$
   N_i = 
   \begin{cases}
   \begin{aligned}
   & \mid F_1 \mid , \ i =1,  \ \mid F_1 \mid \le 0.15N \\
   & 0.15N, i=1,\  \mid F_1 \mid > 0.15N \\
   & \mid F_i \mid \cdot \frac{0.3N-\mid F_1 \mid}{I-1}, i \geq 2
   \end{aligned}
   \end{cases}
   $$

式中： i 表示非支配层等级；F_i表示第 i 级非支配层；N_i 表示从第 i 级非支配层 F_i 中选取的个体数量；$\mid F_i \mid$ 表示第 i 级非支配层上的个体数；N 表示种群大小；I 表示非支配层数

#### 2.3 交叉、变异操作

遗传算法的交叉、变异操作很大程度上决定了遗传算法进化的效率，迄今为止人们已经提出了许多种交叉、变异方法，如单点交叉、双点交叉、均匀交叉等交叉算子，单点变异、逆序变异等变异算子。这些交叉变异方法并不能很好的适应货物配问题中多约束的问题，导致大量的个体经过交叉变异过程之后不但没有进化，反而产生了大量的无效解（不符合约束条件的解），降低算法的搜索效率。

本文采用改进的基于位置的交叉（PBX），首先再两个父代染色体中随机选择几个不连续的位置，将父代染色体1这些位置上的基因复制到子代1相同位置上，再在父代染色体2上将子代1中缺少的基因按照顺序填入。另一个子代以类似方式得到。

改进的PBX交叉如图所示。













#### 2.4 步骤流程

- [x] 文字描述
- [x] 流程图

1. 设置迭代次数、交叉变异概率等初始化参数；
2. 随机生成包含N个个体的初始种群P_0作为第一代父种群P_t；
3. 对父代种群 Pt 进行非支配排序，对个体进行分层，得到各级Pareto非支配层 F1,F2,...,Fn；
4. 利用精英策略对父代种群 Pt 进行筛选，挑选出精英种群 Et，剩余个体即为非精英种群 NEt，其中精英种群作为子代种群 Qt1 直接进入下一代进化，非精英种群进行交叉、变异操作；
5. 利用特殊的交叉、变异算子对非精英种群 NEt 中的个体进行计算，生成子代种群Qt2，合并Qt2 和Qt1得到最终的子代种群Qt；
6. 判断迭代次数 g 是否达到最大，若是则跳转至下一步，否则迭代次数加一跳转至（2）进行下一轮循环。

PDGA流程框架如图6所示。



### 3 快速收敛的PDGA算法

> 阐述当前场景下的问题（货物配载）难点
>
> - 约束条件复杂、搜索空间庞大（提高解的质量），比较迭代次数证明时间降低了，达到同样的效果。
>
> - 如何加快种群收敛？
>   - 提高初始种群的质量
>   - 提高种群多样性：采用双种群策略、自适应交叉变异算子



> 提出一个基本的算法框架，xx的遗传算法（新名字）
>
> 结合物流场景的优化。
>
> 求解帕累托最优解的算法框架（基本算法）前面还有筛选，快速收敛的xx算法，缺点，结合场景来谈，说服力。
>
> 结合场景定性的描述算法的缺点，基本的帕累托遗传算法的算法、优化的帕累托遗传算法，但是优缺点不能泛泛而谈，优点不用列，列缺点，基本的遗传算法缺点123，为什么场景下有这样的缺点，每一条是一段文字（200、300字），最后归纳为自己的改进。
>
> 收敛慢的原因，123分析原因，列出来，对应修改的方法，



> 具体的改进工作：
>
> 1. **提高种群初始解的质量**，设计全局选择和快速选择
>    - 全局选择：按照货物的顺序依次遍历，按照规则生成符合规则的装载清单
>    - 快速选择：随机分配，生成装载清单
>    - 全局选择和快速选择占比为 0.2和0.8
> 2. 双种群策略：
>    - 将种群分类：不符合规则个体、符合规则非Pareto占优解、符合规则Pareto占优解
>    - 不同种类的个体分别采用不同的交叉、变异方法
> 3. 交叉、变异算子：采用自适应的交叉、变异算子，前期高交叉概率，提高种群全局搜索能力，提高进化速度，后期高变异概率，防止陷入局部最优，提高局部搜索能力。

- [x] 不足之处（缺点）
- [x] 改进的总结

相比于传统的遗传算法，引入非支配关系排序的遗传算法在三个目标上的优化效果有显著提升，同时精英保留策略使得种群在进化过程中可以更快地找到第一批可行解，但算法仍采用随机结构，受制于严格的约束条件，随机结构并不适用于庞大的搜索空间，在一定程度上降低了算法的搜索效率。对遗传算法而言，个体的交叉、变异过程对解的质量，以及算法的效率都至关重要，自然环境中，不同的个体本身拥有不同的遗传能力，通过性别鉴定法[参考文献]，可以进一步为不同的个体提高区分度，进而改变其交叉、变异操作，使得最优解逼近真实Pareto前沿，同时提高算法的搜索效率。

为了加快种群的收敛速度，在保证解的多样性的同时使得算法可以更快的达到全局收敛状态，本文基于基础的PDGA算法进行了以下三个部分的改进：

1. 修改种群初始化方法，不再使用随机结构生成全部的初始种群，采用贪心算法和随机结构相结合的方式，快速得到较好的初始解。
2. 引入双种群策略。根据是否符合约束条件将个体分为有效个体与无效个体，再根据性别鉴定法[参考文献]将有效个体分为繁殖能力强的繁殖个体和普通个体，对不同的个体采用不同的交叉、变异操作。
3. 采用自适应的交叉、变异算子。在种群进化前期设置高交叉概率，提高种群全局搜索能力，提高进化速度，后期设置高变异概率，防止陷入局部最优，提高局部搜索能力。



#### 3.1 种群初始化

- [x] 描述介绍

传统的遗传算法利用随机结构生成作为初始父代种群，由于货物配载问题中的约束条件过于复杂，随机生成的个体会有极高的概率不符合约束条件而失效，降低了算法的收敛速度。在实际问题中，可以先利用贪心算法生成一部分装车清单，即符合约束条件的可行解，作为一部分初始种群（P_greedy），之后与随机生成的初始种群（P_random）合并为初始的父代种群，结合精英保留策略，这一部分可行解会成为初代精英解直接进入下一代的进化，直接加快了种群的收敛速度。

两种方式的种群产生比例分别设置为0.3、0.7.

#### 3.2 双种群进化策略

- [x] 描述介绍
- [x] 算法伪代码

多目标进化算法大都采用单一进化策略，在一定程度上降低了算法的搜索能力和收敛速度，增加了算法的随机性。采用双种群进化思想可以提高PDGA进化的方向性和适应性，扩大搜索空间，避免算法陷入局部最优的同时可以加快算法的收敛速度。在进化过程中，根据种群的比例参数和繁殖能力鉴定法将种群拆分为两个种群，并对两个种群采用不同的遗传操作。

其中繁殖能力鉴定法分为计算和评判染色体种群中个体繁殖能力两部分，具体流程如下。

1. 初始化参数：染色体种群规模N，测试种群规模S，种群分割比例参数 β；
2. 随机生成数量为S的测试种群；
3. 计算染色体种群中个体的繁殖能力；
4. 评判染色体种群中个体的繁殖能力；
5. 分割种群。选择繁殖个体中繁殖能力较大的N×β个个体形成子种群1，若数量不够，则挑选普通个体中繁殖能力较大的个体补充；剩余个体形成子种群2。

具体的算法流程如下所示。



#### 3.3 自适应交叉、变异

- [x] 文字描述
- [ ] 多余的方法画图

遗传算法的参数中交叉概率和变异概率的选择是影响遗传算法行为和性能的关键所在，直接影响算法的收敛性。交叉概率越大，新个体产生的速度就越快，然而过大的交叉概率可能会破坏原本的个体基因结构，过小的交叉概率会降低搜索性能。对变异概率来说，过小的变异概率不易产生新的基因结构，过大的变异概率会导致遗产算法变成纯粹的随机搜索算法。

本文针对种群进化的不同阶段，使得交叉概率和变异概率能够自动改变。在种群进化前期，优秀个体距离Pareto最优前沿较远，为保证群体尽快找到支配解，采用较大的交叉概率 P_c，以提高全局搜索能力，加快种群进化过程；在种群进化中后期，种群中已有大部分优秀解，为放置算法陷入局部最优，采用较大的变异概率P_m，以提高局部搜索能力。

交叉概率范围设置为(0.4, 0.8)，变异概率范围设置为(0.01, 0.3)，自适应算子计算公式如下：
$$
自适应算子设计公式
$$


#### 3.4 算法流程

- [x] 文字描述
- [x] 流程图（改改之前画过的）

1. 设置迭代次数、交叉变异概率等初始化参数；
2. 利用贪心算法生成0.3N个个体，再随机生成0.7N个个体，最后合并个体生成包含N个个体的初始种群P_0作为第一代父种群P_t；
3. 对父代种群 Pt 进行非支配排序，对个体进行分层，得到各级Pareto非支配层 F1,F2,...,Fn；
4. 通过繁殖能力鉴定法拆分种群，得到繁殖种群1和普通种群2；
5. 对种群1和种群2分别采用不同的自适应交叉、变异算子操作，得到子代种群；
6. 利用精英策略对子代种群进行筛选，挑选出精英种群，剩余个体即为非精英种群；
7. 合并双种群策略得到两份子代种群，得到新一代种群；
8. 判断迭代次数 g 是否达到最大，若是则跳转至下一步，否则迭代次数加一跳转至（3）进行下一轮循环。

流程图如下所示。

### 4 实验结果与分析

#### 4.1 数据集

京创公司货物库存数据样例展示+说明

#### 4.2 结果及分析

对比NSGA-II和改进的NSGA-II方法，和其他不是帕累托的方法进行比较。都是帕累托解的方法，比较迭代次数，两个指标（写出来计算方法，各个指标的值比较）不是帕累托的方法，得到的解

三个目标对应的最大值、Pareto解的个数、耗时

### 5 结束语





=======
## 小论文

### 没有解决的问题

- 目标设定：车次数最少等价于单辆车的货物总重量最大                                                                                                                       

- 画图（几张图？）

- 转换为word格式（数学公式）



1. 在遗传算法的基础上，设计一个全新的算法，相关工作都列出来算法，及思路，遗传算法和帕累托算法结合设计的新的算法

2. 相关工作写到问题定义后面，没有可以完全应用的场景的代表性算法，不同方向的算法挑一个代表性算法（不止是遗传算法）为什么从遗传算法的角度来写。一定要写明为什么遗传算法，这是主要的方法。问题是np的，（参考文献证明），近似算法为什么用遗传算法，

   > 

3. 场景文字描述，分货过程有多个目标，再用数学语言写出来，

多目标在这个场景下没有工作，其他场景有类似的，已经证明是np问题，参考文献，第一类方法如何解决（思路）代表性的论文，什么场景用了这个方法，第二类、第三类。。

我选择遗传算法的原因，

- 算法框架：货物预处理，候选集，得到结果（遗传算法的框架）
- 求近似解的思路，
- 为什么这么设计？两大段文字？（700字design思路）





1. 模型
2. 算法框架+可以求出这个解（和其他算法比较，为什么要这么设计这个算法，结合相关工作和场景）
   - 能不能求准确解（用近似算法）
   - 为什么要选帕累托概念（别人的算法证明效果要好，可以体现目标之间的冲突，当前的场景适用这种方法，所以适用）
3. 收敛的速度很慢，对算法做优化（性能）
4. 或者结合2和3点，快速收敛（帕累托+遗传算法）的算法，将算法特点，np的，帕累托方法，做出决策的原因，存在收敛的问题，为了应对这些挑战，做的设计。
5. 遗传算法，权重的速度快，解的质量不高，帕累托的解质量高，速度慢，如何在保证解的质量的情况下加快迭代的速度。

### 摘要

> 200-400字
>
> 摘要应简明扼要，避免一般背景介绍，应包括研究目的，方法及过程，结果和结论这些要素，不要出现“本文”、“我们”之类词



### 0 引言

> - 背景说明
> - 相关工作
> - 本文贡献

#### 相关工作

#### 本文贡献

1. 设计了一套货物配载多目标优化模型

### 1 配载多目标优化模型

根据实际的建立货物配载多目标优化模型

#### 1.1 问题描述



#### 1.2 模型建立

> - 三个目标方程及对应的解释说明
> - 约束条件及解释说明

货物配载过程即根据当前时间下的库存，对货物进行组合、拆分，在符合实际约束条件的情况下，生成多份货车装载订单。

本文根据实际的业务调研结果，从物流平台和货车司机双方的角度考虑，设计以下3个具有实际应用价值的目标，从物流平台的角度考虑，通过增加单批次所有订单的货物总重量，减少单批次订单数即减少车次数来降低平台成本，通过在不超载的情况下尽可能增大单辆车的装载重量，从而在提高配载效率的同时可以提升平台经济收益；从货车司机的角度考虑，尽可能降低货车中货物的装卸地数量，可减少司机的时间成本，给司机带来最大的便利。同时这三个目标具有优先级，优先最大化所有订单的货物总重量，其次减少总订单数，减少总订单的货物装卸地优先级最低。

根据对货物配载问题的分析，货物配载模型主要参数如下：

i 表示可供使用的车辆集合，{1, 2, ..., m}；j 表示当前库存可发运货物集合，{1, 2, ..., n}；$w_j$ 表示货物 j 的重量，单位为吨；$c_i$ 表示车辆 i 的载重上限，单位为吨，并根据货物种类进行区分；$q_i$ 表示车辆 i 上的货物装卸地数总和，属于2，3，4，至少一装一卸，最多两装两卸

模型的目标方程如下所示：
$$
\begin{cases}
\begin{align}
& maximize \ \ \ \ \ \ \  f_1 = \sum_{i=1}^m\sum_{j=1}^n w_jx_{ij} \\
& maximize \ \ \ \ \ \ \  f_2 = \sum_{j=1}^nw_jx_{ij} \\
& minimize \ \ \ \ \ \ \  f_3 =  \sum_{i=1}^mq_i
             \\
& subject \ \ to.\quad \ \sum_{j=1}^nw_jx_{ij} \leq c_i ,\quad i \in M = \left \{ 1, \cdots, m \right \} .\\
& \ \quad \quad \quad \quad \quad \quad \sum_{i=1}^nx_{ij} \leq 1 , \quad j \in N = \left \{ 1, \cdots, n \right \} .\\
& 其中 \ \quad\quad \quad\quad \ 
x_{ij}=
\begin{cases} 
0,\quad 如果货物 j 没有被分配至货车 i \\
1,\quad 如果货物 j 被分配至货车 i 
\end{cases}
\end{align}
\end{cases}
$$

式（1）表示最大化总订单货物重量

式（2）表示最大化单辆车货物总重量

式（3）表示最小化货车货物装卸地数量

式中的 $x_{ij}$ 为0或者1，表示货物j是否被分配至车辆i中。

约束条件：

1. 每件货只能被放置一次，不可同时被放置在不同的车辆中

2. 每辆车中装载的货物总重量不得超过货车的载重上限

3. 每辆车的运货目的地区县唯一，即运往不同城市、不同区县的货物不可被放置在一辆车中
   $$
   \sum _{j=1}^{n}
   $$
   
4. 共有三个装货仓库：西区、老区、岚北岗，每辆车的装货仓库唯一

5. 货物拼货规则（卷类只能和卷类拼货、非卷只能和非卷类拼货，即卷类和非卷类不能共存在一辆车上）

### 2 Pareto dominated genetic algorithm（PDGA）



基本的算法框架

> 1. 传统的遗传算法的缺点：实际问题中目标互相冲突，传统的遗传算法没有体现多目标的竞争性、



> 提出一个基本的算法框架，xx的遗传算法（新名字）
>
> 结合物流场景的优化。
>
> 求解帕累托最优解的算法框架（基本算法）前面还有筛选，快速收敛的xx算法，缺点，结合场景来谈，说服力。
>
> 结合场景定性的描述算法的缺点，基本的帕累托遗传算法的算法、优化的帕累托遗传算法，但是优缺点不能泛泛而谈，优点不用列，列缺点，基本的遗传算法缺点123，为什么场景下有这样的缺点，每一条是一段文字（200、300字），最后归纳为自己的改进。
>
> 收敛慢的原因，123分析原因，列出来，对应修改的方法，

传统的遗传算法

本文提出的PDGA算法，主要在遗传算法（GA）[参考文献]的基础上进行了以下三个优化。

1. 引入pareto支配关系[参考文献]，利用其支配关系对解进行分类（分层），使得好的个体有更大的机会遗传到下一代。
2. 使用精英保留策略，保留父代种群中的非支配解，使其直接进入子代种群，避免父代中优秀个体的丢失。
3. 设计独立的交叉、变异算子，

### 3 NSGA-II算法的应用与改进

> 阐述当前场景下的问题（货物配载）难点
>
> - 约束条件复杂、搜索空间庞大（提高解的质量），比较迭代次数证明时间降低了，达到同样的效果。
>
> - 如何加快种群收敛？
>   - 提高初始种群的质量？
>   - 提高种群多样性：修改交叉、变异方案

> 具体的改进工作：
>
> 1. **提高种群初始解的质量**，设计全局选择和快速选择
>    - 全局选择：按照货物的顺序依次遍历，按照规则生成符合规则的装载清单
>    - 快速选择：随机分配，生成装载清单
>    - 全局选择和快速选择占比为 0.2和0.8
> 2. 双种群策略：
>    - 将种群分类：不符合规则个体、符合规则非Pareto占优解、符合规则Pareto占优解
>    - 不同种类的个体分别采用不同的交叉、变异方法
> 3. 交叉、变异算子：采用自适应的交叉、变异算子，前期高交叉概率，提高种群全局搜索能力，提高进化速度，后期高变异概率，防止陷入局部最优，提高局部搜索能力。

### 4 实验结果与分析

#### 4.1 数据集

京创公司货物库存数据样例展示+说明

#### 4.2 结果及分析

对比NSGA-II和改进的NSGA-II方法，和其他不是帕累托的方法进行比较。都是帕累托解的方法，比较迭代次数，两个指标（写出来计算方法，各个指标的值比较）不是帕累托的方法，得到的解

三个目标对应的最大值、Pareto解的个数、耗时

### 5 结束语





>>>>>>> Stashed changes
